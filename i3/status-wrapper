#!/usr/bin/env perl
# vim:ts=4:sw=4:expandtab
#
# i3/status-wrapper
# © 2013 Charles Lehner, MIT License
#
# based on wrapper.pl © 2012 Michael Stapelberg, Public Domain
# and some Perl stuff I found online

# This script is a wrapper which prefixes each i3status line with custom
# information. To use it, ensure your ~/.i3status.conf contains this line:
#     output_format = "i3bar"
# in the 'general' section.
# Then, in your ~/.i3/config, use:
#     status_command status-wrapper -c .i3/status.conf
# In the 'bar' section.
#
# Currently, this script adds arbitrary data from a socket connection,
# e.g. a bitcoin ticker

use strict;
use warnings;
use IO::Select;
use IO::Socket::INET;

my $btc_host = 'celehner.com';
my $btc_port = 9980;

# Don’t buffer any output.
$| = 1;

# Process args
my $i3status_args = '';
if ($#ARGV == 1 and shift eq '-c') {
    $i3status_args = '-c ' . shift
}

# Start i3status
open(STATUS,'i3status ' . $i3status_args . '|') or die "Unable to run i3status";

# Skip the first line which contains the version header.
print scalar <STATUS>;

# The second line contains the start of the infinite array.
print scalar <STATUS>;

# Select on network stuff and stin
# create handle set for reading
my $read_set = new IO::Select();

# add stdin (i3status) to the set
$read_set->add(\*STATUS);

# Connect to btc quote server
my $btc_rate = '';
my $btc_h = 0;

sub btc_connect {
    $btc_h = new IO::Socket::INET(
        PeerAddr => $btc_host,
        PeerPort => $btc_port,
        Proto    => 'tcp',
        Blocking => 0
    );
    if (!$btc_h) {
        # could not create socket
        #print "unable to create"
    } else {
        $read_set->add($btc_h);
    }
}
btc_connect();

while (my (@rh_set) = $read_set->can_read()) {
    if (!$btc_h) {
        #print "connecting";
        btc_connect();
    }
    # get a set of readable handles (blocks until at least one handle is ready)
    # take all readable handles in turn
    foreach my $rh (@rh_set) {
        # get input from i3status
        if ($rh == \*STATUS) {
            do_status();
        }
        # get input from btc socket
        elsif ($rh == $btc_h) {
            my $buf;
            if (sysread($rh, $buf, 16)) {
                $btc_rate = '$' . int($buf + 0.5);
            } else {
                # client closed socket
                $read_set->remove($rh);
                $btc_rate = '?';
                $btc_h = 0;
                # reconnect later
            }
        }
    }
}

sub do_status {
    # Read status line, ignore a comma at the beginning if it exists.
    my $buf = <STATUS>;
    if (!$buf) {
        # i3status exited
        die("\ni3status exited\n");
    }
    my ($statusline) = ($buf =~ /^,?\[(.*)\]/);
    # Prefix our own information.
    my $prepend = '{"full_text":"' . $btc_rate . '","name":"btc"}';
    $statusline = $prepend . ',' . $statusline;

    # Output the line as JSON.
    print "[" . $statusline . "],\n";
}
